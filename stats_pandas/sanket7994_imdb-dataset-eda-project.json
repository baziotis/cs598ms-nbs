{
  "cells": [
    {
      "raw": "# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport os\nimport pandas as pd\nimport matplotlib.pyplot as plt # ploting graphs and chart \nfrom datetime import timedelta # for time formatting\n\n# Input data files are available in the read-only \"../input/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('../input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session",
      "total-ns": 1561079220
    },
    {
      "raw": "df = pd.read_table('../input/imdb-official-movies-dataset/title-ratings.tsv', low_memory=False)\ndf2 = pd.read_table('../input/imdb-official-movies-dataset/title-metadata.tsv',low_memory=False)\nif \"IREWR_LESS_REPLICATION\" in os.environ and os.environ[\"IREWR_LESS_REPLICATION\"] == \"True\":\n    df2 = df2[:1_500_000]",
      "total-ns": 25758745631
    },
    {
      "raw": "# Merging Rating and MetaData datsets into single dataframe w.r.t common column\nmain_df = pd.merge(df,df2,on='tconst')\nmain_df.head()",
      "total-ns": 11347783517
    },
    {
      "raw": "# creating a copy \nimdb_df = main_df.copy()",
      "total-ns": 336624249
    },
    {
      "raw": "imdb_df['runtimeMinutes'].value_counts()",
      "total-ns": 37664645
    },
    {
      "raw": "# Replace object type string '\\N' with NaN First\nimdb_df['runtime_delta'] = pd.to_numeric(imdb_df['runtimeMinutes'], errors='coerce', downcast=\"integer\")",
      "total-ns": 464292770
    },
    {
      "raw": "# Using 'pd.to_timedelta' to convert minutes into desired format\nimdb_df['runtime_delta'] = pd.to_timedelta(imdb_df['runtime_delta'], unit='m')",
      "total-ns": 52193048
    },
    {
      "raw": "imdb_df['isAdult'].unique()",
      "total-ns": 35183801
    },
    {
      "raw": "# Replace string and int by boolean\n# we will leave out '2014' and '2020' as it is as there`s no way to confirm If they Adult or not not\nimdb_df['isAdult'] = imdb_df['isAdult'].map({'0': 'Non_Adult_Title', '1': 'Adult_Title'})",
      "total-ns": 179988752
    },
    {
      "raw": "imdb_df.isAdult = imdb_df.isAdult.fillna('Unrated')\nimdb_df['isAdult'].unique()",
      "total-ns": 128409524
    },
    {
      "raw": "# First, we should replace '\\N' values to nan so next step\nimdb_df['startYear'] = imdb_df['startYear'].replace('\\\\N', np.NaN)\nimdb_df['endYear'] = imdb_df['endYear'].replace('\\\\N', np.NaN)",
      "total-ns": 294164621
    },
    {
      "raw": "# Now joinning them\n# STEFANOS-DISABLE-FOR-MODIN\n### ORIGINAL ###\n# imdb_df['premiere_timeline'] = imdb_df[['startYear','endYear']].stack().groupby(level=0).agg('-'.join)\n### COMPATIBLE WITH MODIN ###\n# I tried a bunch of things, here's one:\n#   imdb_df['premiere_timeline'] = imdb_df[['startYear','endYear']].stack().groupby(level=0).apply('-'.join)\n# They don't seem to work. The problem seems to be with groupby(level=0). Generally, I'm not sure that Modin can\n# groupby MultiIndex's.\n# So, below I do the computation up to the stacking, just so that we can keep as much of it as possible (in case\n# Modin, or some other system that uses the same benchmarks, can optimize it; we don't want to deprive this\n# opportunity). Unfortunately, we cannot assign the result of stacking to premiere_timeline as they don't match.\n# I just assign a dumb value to premiere_timeline so that it exists in the DF. It's not used later.\n\n_ = imdb_df[['startYear','endYear']].stack()\nimdb_df['premiere_timeline'] = 0",
      "total-ns": 387269714
    },
    {
      "raw": "# Drop unneccessory columns from dataframe\ncolumns_to_keep = ['tconst','averageRating','numVotes','titleType','primaryTitle',\n                   'isAdult','premiere_timeline','runtime_delta']\n\nimdb_df = imdb_df[columns_to_keep]\n\n# Also renaming them with approriate name\nrenamed_cols = {'tconst':'IMDB_ID','averageRating':'Avg_Rating','numVotes':'Total_Votes',\n                'titleType':'Title_Category','primaryTitle':'Title_Name','isAdult':'IN-18+'\n                ,'premiere_timeline':'Air_time','runtime_delta':'Title_Runtime_Length'}\n\nimdb_df.rename(columns = renamed_cols,inplace=True)\nimdb_df.head()",
      "total-ns": 135593423
    },
    {
      "raw": "top_10_highest = imdb_df.groupby(['Title_Name'])[\n    ['Avg_Rating','Total_Votes']].max().sort_values(by=['Avg_Rating','Total_Votes'\n                                                       ], ascending = False).reset_index().head(10)\n\ntop_10_highest",
      "total-ns": 2739747568
    },
    {
      "raw": "highest_rated_type = imdb_df.groupby(['Title_Category'])[['Avg_Rating','Total_Votes']].mean(\n).sort_values(by=['Avg_Rating','Total_Votes'], ascending = False).reset_index().round(decimals = 1)\n\nhighest_rated_type",
      "total-ns": 89029233
    },
    {
      "raw": "longest_runtime = imdb_df.loc[imdb_df.groupby(['Title_Category'], \n                                              sort=False)['Title_Runtime_Length'].idxmax()\n                             ][['Title_Category', 'Title_Name', 'Title_Runtime_Length']]\n\nlongest_runtime.sort_values(by='Title_Runtime_Length', ascending = False).reset_index(drop=True)",
      "total-ns": 111721399
    },
    {
      "raw": "shortest_runtime = imdb_df.loc[imdb_df.groupby(['Title_Category'], \n                                              sort=False)['Title_Runtime_Length'].idxmin()\n                             ][['Title_Category', 'Title_Name', 'Title_Runtime_Length']]\n\nshortest_runtime.reset_index(drop=True)",
      "total-ns": 94710268
    },
    {
      "raw": "wanna_adult_or_not = imdb_df.groupby(['Title_Category','IN-18+']\n                                    )['Avg_Rating'].agg('mean').round(1).unstack(fill_value= 0) \nwanna_adult_or_not.reset_index(inplace = True)\n##### Visualise the chart in stack manner of bar type\n\n# STEFANOS: Disable plotting\n# plt.rcParams['figure.figsize'] = [15, 8]\n# wanna_adult_or_not.plot(x='Title_Category', kind='bar', stacked=True, \n#                         title='Average Ratings of Non_Adult Rated Titles vs Adult Rated Titles')\n# plt.xlabel('Title Categories')\n# plt.ylabel('Average Ratings')\n# plt.show()",
      "total-ns": 124614081
    },
    {
      "raw": "",
      "total-ns": 106990
    }
  ]
}